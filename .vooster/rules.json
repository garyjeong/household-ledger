{
  "rules": [
    {
      "type": "prd",
      "content": "## 제품 개요\n신혼부부가 각자 입력해도 자동으로 하나의 가계부로 묶여 지출을 투명하게 공유할 수 있는 ‘수동 입력 위주의 초간단 가계부’.\n\n## 목표\n1. 두 사람이 지출‧수입을 빠르게 기록하고, 실시간으로 공동 가계부를 확인할 수 있다.\n2. 월별·카테고리별 시각화를 통해 소비 패턴을 쉽고 재미있게 파악한다.\n3. 예산 설정과 초과 알림으로 과소비를 방지한다.\n4. 구현은 MVP → 피드백 기반 점진적 확장 전략으로 단순하고 가벼운 UX 유지.\n\n## 핵심 지표(KPI)\n- 월간 활성 사용자(MAU) 1,000명\n- 일 평균 입력 완료 시간 ≤ 10초\n- 가족코드 초대 성공률 90% 이상\n- 예산 초과 알림 클릭률 30% 이상\n\n## 타겟 사용자 페르소나\n1. 김신혼(30세, 직장인)\n   - 결혼 3개월 차, 월급 통장 공개는 부담스럽지만 지출 투명성은 필요\n   - 목표: 월 생활비 200만원 안에서 소비\n2. 박신혼(29세, 디자이너)\n   - 가계부 경험 없음, 시각적 그래프를 선호\n   - 목표: 커피·쇼핑 지출을 줄이고 저축률 ↑\n\n## 주요 기능(Release 1 – MVP)\n1. 회원가입 / 로그인\n   - 이메일·비밀번호, 소셜 로그인(구글·애플) 선택\n2. 가족코드 그룹 연동\n   - 10자리 영문+숫자 코드 생성 & 입력으로 1가구 1가계부 연결\n3. 수입·지출 입력/편집/삭제\n   - 항목명, 금액, 카테고리, 통화(선택), 메모, 날짜\n4. 카테고리 관리\n   - 기본 카테고리 제공 + 사용자 정의 추가/편집/삭제\n5. 다중 통화 지원(선택)\n   - 무료 환율 API(예: exchangerate.host) 실시간 환율 적용\n\n## 부가 기능(Release 2)\n1. 월별·카테고리별 통계/그래프(파이, 바차트)\n2. 예산 설정 & 초과 알림(Push, In-app)\n3. 반복 지출 자동 등록(월세, 구독료 등)\n4. 빠른 입력 위젯(모바일 홈 화면)\n\n## 비기능 요구사항\n- 반응형: 모바일 퍼스트, 데스크탑 1280px 이상 대응\n- 성능: 첫 페이지 LCP 2.5초 이내\n- 보안: bcrypt 해시, HTTPS 강제, 코드 기반 그룹 연결 시 24시간 만료\n- 데이터 백업: Firebase/Supabase 실시간 DB + 자동 일일 백업\n\n## 제약 사항\n- 외부 금융 API 연동 없음(수동 입력 컨셉 유지)\n- 무료 환율 API 호출 분당 10회 제한 → 캐싱 적용\n\n## 제품 로드맵\n| 분기 | 목표 | 주요 작업 |\n| --- | --- | --- |\n| Q1 | MVP 출시 | 핵심 기능 1~5, 반응형 UI, 가족코드 연결 |\n| Q2 | 분석 기능 | 통계/그래프, 예산 알림, UX 개선 |\n| Q3 | 자동화 | 반복 지출, 입력 위젯, PWA 설치 지원 |\n| Q4 | 확장 | 다국어 지원, 프리미엄 플랜 탐색 |\n\n## 성공 기준\n- 출시 3개월 내 평점 4.5/5 이상\n- 사용자 유지율 60% 이상(30일)\n- 입력 건당 평균 2.5초 감소(버전 업 후)\n\n## 리스크 & 대응\n1. 입력 번거로움 지속 → 빠른 입력 UX 개선, 위젯 우선 개발\n2. 그룹 연결 실패율↑ → 코드 길이·만료 시간 최적화, QR 옵션 백업\n3. 환율 API 다운 → 캐싱 및 백업 API 구축",
      "writedAt": "2025-08-27T01:57:42.221Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **Project Overview**: 신혼부부를 위한 간단한 수동 입력 기반 가계부 웹 애플리케이션 개발. Next.js를 사용하여 빠르고 반응성이 뛰어난 사용자 경험을 제공하고, Supabase를 통해 데이터베이스 및 인증 기능을 관리한다.\n- **Core Technology Stack**: Next.js 14, React, TypeScript, TailwindCSS, Supabase, PostgreSQL, Vercel, exchangerate.host, Playwright, Vitest, ESLint, Prettier\n- **Key Technical Objectives**:\n    - **Performance**: 첫 페이지 로딩 시간 2.5초 이내 달성 및 일 평균 입력 완료 시간 10초 이내 유지.\n    - **Scalability**: 월간 활성 사용자(MAU) 1,000명 이상 지원.\n    - **Reliability**: 높은 가족코드 초대 성공률(90% 이상) 및 안정적인 환율 정보 제공.\n- **Critical Technical Assumptions**:\n    - exchangerate.host API의 안정적인 제공.\n    - Supabase의 안정적인 데이터베이스 및 인증 서비스 제공.\n    - 사용자들이 수동 입력 방식을 선호한다는 가정.\n\n## 2. Tech Stack\n\n| Category          | Technology / Library        | Reasoning (Why it's chosen for this project) |\n| ----------------- | --------------------------- | -------------------------------------------- |\n| Framework         | Next.js 14                | 서버 사이드 렌더링(SSR) 및 정적 사이트 생성(SSG) 지원, 빠른 페이지 로딩 속도 및 SEO 최적화 |\n| UI Library        | React                       | 컴포넌트 기반 개발, 재사용성 및 유지보수 용이성 |\n| Language          | TypeScript                  | 정적 타입 검사, 코드 안정성 및 개발 생산성 향상 |\n| Styling           | TailwindCSS                 | 유틸리티 우선 CSS 프레임워크, 빠른 스타일링 및 반응형 디자인 지원 |\n| Backend / DB      | Supabase, PostgreSQL          | BaaS(Backend as a Service) 제공, 인증, 데이터베이스, 실시간 업데이트 기능 제공, PostgreSQL의 안정성 및 확장성 |\n| Hosting           | Vercel                      | Next.js에 최적화된 서버리스 배포 플랫폼, 자동 스케일링 및 CDN 지원 |\n| Currency API      | exchangerate.host          | 무료 환율 API 제공, 다중 통화 지원 기능 구현 |\n| Testing (E2E)     | Playwright                  | End-to-End 테스트 자동화, 사용자 시나리오 기반 테스트 용이성 |\n| Testing (Unit)    | Vitest                      | 빠른 Unit 테스트 실행, 코드 품질 확보 |\n| Linting           | ESLint                      | 코드 스타일 규칙 적용, 코드 품질 및 일관성 유지 |\n| Formatting        | Prettier                    | 자동 코드 포맷팅, 코드 스타일 일관성 유지 |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n- **Frontend (Next.js Application)**:\n    - 사용자 인터페이스 및 사용자 상호 작용 처리.\n    - React 컴포넌트 기반으로 구축.\n    - TailwindCSS를 사용한 스타일링.\n    - 기능 모듈:\n        - 인증 (로그인, 회원가입)\n        - 가계부 (수입/지출 입력, 편집, 삭제)\n        - 통계 (월별, 카테고리별 통계)\n        - 예산 (예산 설정, 초과 알림)\n        - 설정 (사용자 설정, 가족 코드 관리)\n- **Backend (Supabase)**:\n    - 데이터베이스: PostgreSQL\n    - 인증: 사용자 인증 및 권한 관리.\n    - API: Frontend와 데이터 통신을 위한 API 제공.\n    - 기능 모듈:\n        - 사용자 관리\n        - 가계부 데이터 관리\n        - 통계 데이터 생성\n        - 예산 관리\n- **External API (exchangerate.host)**:\n    - 실시간 환율 정보 제공.\n    - 환율 정보를 캐싱하여 API 호출 제한 극복.\n\n### Top-Level Component Interaction Diagram\n\n```mermaid\ngraph TD\n    A[Frontend (Next.js)] --> B[Backend (Supabase)]\n    B --> C[PostgreSQL]\n    A --> D[exchangerate.host API]\n```\n\n- Frontend (Next.js)는 사용자 인터페이스를 제공하고, 사용자 입력을 받아 Backend (Supabase)에 API 요청을 보낸다.\n- Backend (Supabase)는 API 요청을 처리하고, 데이터베이스(PostgreSQL)에 데이터를 저장하거나 조회한다.\n- Frontend (Next.js)는 환율 정보가 필요한 경우 exchangerate.host API에 직접 요청한다.\n- exchangerate.host API는 실시간 환율 정보를 Frontend (Next.js)에 제공한다.\n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**\n- **Domain Separation**: 사용자 관리, 가계부 관리, 통계 관리, 예산 관리 등으로 도메인 분리.\n- **Layer-Based Architecture**: presentation (UI 컴포넌트), business logic (서비스), data access (Supabase API 호출) 레이어로 분리.\n- **Feature-Based Modules**: 각 기능별로 모듈을 구성하여 코드 재사용성 및 유지보수성 향상.\n- **Shared Components**: 공통 유틸리티, 타입, 재사용 가능한 컴포넌트를 별도 모듈로 관리.\n\n**Universal File & Folder Structure**\n```\n/\n├── components/          # 재사용 가능한 UI 컴포넌트\n│   ├── button/\n│   │   ├── Button.tsx\n│   │   └── Button.module.css\n│   ├── input/\n│   │   ├── Input.tsx\n│   │   └── Input.module.css\n│   └── ...\n├── pages/               # Next.js 페이지 컴포넌트 (라우팅)\n│   ├── _app.tsx          # 전역 레이아웃 및 스타일 설정\n│   ├── index.tsx         # 메인 페이지\n│   ├── login.tsx         # 로그인 페이지\n│   ├── register.tsx      # 회원가입 페이지\n│   └── ...\n├── services/            # 비즈니스 로직 및 API 호출\n│   ├── auth.ts           # 인증 관련 서비스\n│   ├── household.ts      # 가계부 관련 서비스\n│   ├── statistics.ts     # 통계 관련 서비스\n│   └── ...\n├── utils/               # 공통 유틸리티 함수\n│   ├── currency.ts       # 통화 관련 유틸리티\n│   ├── date.ts           # 날짜 관련 유틸리티\n│   └── ...\n├── types/               # TypeScript 타입 정의\n│   ├── household.ts      # 가계부 데이터 타입\n│   ├── user.ts           # 사용자 데이터 타입\n│   └── ...\n├── public/              # 정적 파일 (이미지, 폰트 등)\n├── styles/              # 전역 스타일 시트 (TailwindCSS 설정)\n│   ├── global.css\n│   └── tailwind.config.js\n├── .eslintrc.js         # ESLint 설정 파일\n├── .prettierrc.js       # Prettier 설정 파일\n├── tsconfig.json        # TypeScript 설정 파일\n└── package.json         # 프로젝트 의존성 및 스크립트 관리\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: API request/response 패턴 (RESTful API)\n- **Database Interaction**: Supabase 클라이언트 라이브러리 사용, PostgreSQL 데이터베이스에 직접 쿼리.\n- **External Service Integration**: exchangerate.host API 호출, 환율 정보 캐싱.\n- **Real-time Communication**: 필요시 Supabase의 실시간 데이터베이스 기능을 활용하여 데이터 동기화.\n- **Data Synchronization**: 데이터 일관성을 위해 Supabase 트랜잭션 사용.\n\n## 4. Performance & Optimization Strategy\n- **Code Splitting**: Next.js의 Code Splitting 기능을 활용하여 초기 로딩 시간을 최소화.\n- **Image Optimization**: 이미지 최적화 및 Lazy Loading 적용.\n- **Caching**: 환율 정보 및 자주 사용되는 데이터 캐싱.\n- **Database Optimization**: 데이터베이스 쿼리 최적화 및 인덱싱 적용.\n\n## 5. Implementation Roadmap & Milestones\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: Next.js 프로젝트 설정, Supabase 데이터베이스 및 인증 설정, TailwindCSS 설정.\n- **Essential Features**: 회원가입 / 로그인, 가족코드 그룹 연동, 수입·지출 입력/편집/삭제, 카테고리 관리, 다중 통화 지원.\n- **Basic Security**: bcrypt 해시, HTTPS 강제, 코드 기반 그룹 연결 시 24시간 만료.\n- **Development Setup**: 개발 환경 구축, CI/CD 파이프라인 설정.\n- **Timeline**: 3개월 (Q1)\n\n### Phase 2: Feature Enhancement\n- **Advanced Features**: 월별·카테고리별 통계/그래프, 예산 설정 & 초과 알림(Push, In-app), 반복 지출 자동 등록.\n- **Performance Optimization**: 시스템 성능 개선 및 최적화.\n- **Enhanced Security**: 보안 기능 강화 및 취약점 점검.\n- **Monitoring Implementation**: 시스템 모니터링 및 로깅 설정.\n- **Timeline**: 3개월 (Q2)\n\n## 6. Risk Assessment & Mitigation Strategies\n### Technical Risk Analysis\n- **Technology Risks**: exchangerate.host API 다운 또는 변경, Supabase 서비스 장애.\n    - **Mitigation Strategies**: 환율 정보 백업 API 구축, Supabase 장애 대비 데이터 백업 및 복구 전략 마련.\n- **Performance Risks**: 데이터 증가에 따른 성능 저하, API 호출 제한.\n    - **Mitigation Strategies**: 데이터베이스 쿼리 최적화, 캐싱 전략 강화, API 호출 제한 회피.\n- **Security Risks**: 사용자 데이터 유출, 인증 우회.\n    - **Mitigation Strategies**: 보안 취약점 점검 및 패치, 데이터 암호화, 강력한 인증 정책 적용.\n- **Integration Risks**: 타사 API 연동 실패.\n    - **Mitigation Strategies**: API 연동 테스트 강화, API 변경에 대한 빠른 대응 체계 구축.\n\n### Project Delivery Risks\n- **Timeline Risks**: 개발 일정 지연, 예상치 못한 기술적 문제 발생.\n    - **Contingency Plans**: 일정 관리 및 우선순위 조정, 기술적 문제 해결을 위한 전문가 지원.\n- **Resource Risks**: 개발 인력 부족, 핵심 개발자 이탈.\n    - **Contingency Plans**: 추가 개발 인력 확보, 지식 공유 및 문서화 강화.\n- **Quality Risks**: 코드 품질 저하, 버그 발생.\n    - **Contingency Plans**: 코드 리뷰 강화, 테스트 자동화, 버그 추적 시스템 구축.\n- **Deployment Risks**: 배포 실패, 환경 설정 문제.\n    - **Contingency Plans**: 배포 자동화, 롤백 전략 마련, 환경 설정 문서화.\n",
      "writedAt": "2025-08-27T01:57:42.221Z"
    },
    {
      "type": "guideline",
      "content": "# Code Guidelines for 신혼 가계부\n\n## 1. Project Overview\n\nThis project is a simple, manual-input-focused household accounting web application for newlyweds. It's built using Next.js, React, TypeScript, TailwindCSS, Supabase, and PostgreSQL, deployed on Vercel. Key architectural decisions include:\n\n-   **Frontend**: Next.js for SSR/SSG, React for UI components, TailwindCSS for styling.\n-   **Backend**: Supabase for authentication and database (PostgreSQL).\n-   **External API**: exchangerate.host for currency exchange rates.\n-   **Domain-Driven Design**: Application structure based on domains like authentication, household management, statistics, and budget management.\n\n## 2. Core Principles\n\n-   **Maintainability**: Write code that is easy to understand, modify, and extend.\n-   **Readability**: Code should be clear, concise, and well-documented.\n-   **Testability**: Design code that is easy to test using unit and E2E tests.\n-   **Performance**: Optimize for speed and efficiency, ensuring a smooth user experience.\n-   **Security**: Protect user data and prevent vulnerabilities through secure coding practices.\n\n## 3. Language-Specific Guidelines\n\n### TypeScript\n\n#### File Organization and Directory Structure\n\nFollow the defined structure in the TRD:\n\n```\n/\n├── components/\n├── pages/\n├── services/\n├── utils/\n├── types/\n├── public/\n├── styles/\n├── .eslintrc.js\n├── .prettierrc.js\n├── tsconfig.json\n└── package.json\n```\n\n#### Import/Dependency Management\n\n-   **MUST**: Use absolute imports for modules within the project.\n-   **MUST**: Group imports by origin (e.g., node modules, third-party libraries, project modules).\n-   **MUST**: Keep dependency lists in `package.json` up-to-date.\n\n```typescript\n// MUST: Example of correct import style\nimport React from 'react';\nimport { useState } from 'react';\nimport { createHousehold } from '@/services/household';\nimport { formatDate } from '@/utils/date';\nimport { Household } from '@/types/household';\n```\n\n#### Error Handling Patterns\n\n-   **MUST**: Use `try...catch` blocks for handling potential errors in asynchronous operations (e.g., API calls).\n-   **MUST**: Provide informative error messages to the user.\n-   **MUST**: Log errors to the console or a logging service for debugging.\n-   **MUST**: Define custom error types for specific scenarios.\n\n```typescript\n// MUST: Example of error handling in API calls\nasync function fetchData() {\n    try {\n        const response = await fetch('/api/data');\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        return data;\n    } catch (error: any) {\n        console.error('Failed to fetch data:', error);\n        // Display user-friendly error message\n        // Optionally, send error to a logging service\n        throw new Error('Failed to fetch data. Please try again.');\n    }\n}\n```\n\n### React/Next.js\n\n#### Component Structure\n\n-   **MUST**: Create reusable components for UI elements.\n-   **MUST**: Use functional components with hooks.\n-   **MUST**: Separate UI logic from business logic.\n-   **MUST**: Use descriptive names for components.\n\n```typescript\n// MUST: Example of a functional component\nimport React from 'react';\n\ninterface Props {\n    text: string;\n}\n\nconst MyComponent: React.FC<Props> = ({ text }) => {\n    return <div>{text}</div>;\n};\n\nexport default MyComponent;\n```\n\n#### State Management\n\n-   **MUST**: Use React's `useState` hook for local component state.\n-   **SHOULD**: Use Context API for application-wide state that doesn't require frequent updates.\n-   **MUST NOT**: Use Redux or other complex state management libraries unless absolutely necessary.\n\n#### Data Fetching\n\n-   **MUST**: Use `getServerSideProps` or `getStaticProps` in Next.js for server-side rendering or static site generation when appropriate.\n-   **MUST**: Use `useEffect` hook for client-side data fetching.\n-   **MUST**: Handle loading and error states when fetching data.\n\n```typescript\n// MUST: Example of getServerSideProps\nimport { GetServerSideProps } from 'next';\n\ninterface Props {\n    data: any;\n}\n\nconst MyPage: React.FC<Props> = ({ data }) => {\n    return <div>{JSON.stringify(data)}</div>;\n};\n\nexport const getServerSideProps: GetServerSideProps = async (context) => {\n    const res = await fetch('https://api.example.com/data');\n    const data = await res.json();\n\n    return {\n        props: { data },\n    };\n};\n\nexport default MyPage;\n```\n\n### TailwindCSS\n\n#### Styling Conventions\n\n-   **MUST**: Use utility classes provided by TailwindCSS.\n-   **MUST**: Avoid writing custom CSS unless absolutely necessary.\n-   **MUST**: Keep class names concise and readable.\n-   **MUST**: Use `@apply` directive sparingly, and only for logical groupings of styles.\n\n```html\n// MUST: Example of using TailwindCSS classes\n<button className=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\">\n    Click me\n</button>\n```\n\n### Supabase\n\n#### Data Access\n\n-   **MUST**: Use the Supabase client library for database interactions.\n-   **MUST**: Handle errors appropriately when querying the database.\n-   **MUST**: Use environment variables for Supabase credentials.\n-   **MUST**: Implement Row Level Security (RLS) policies to protect data.\n\n```typescript\n// MUST: Example of fetching data from Supabase\nimport { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\nconst supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\n\nif (!supabaseUrl || !supabaseKey) {\n    throw new Error('Supabase URL and Key must be set as environment variables.');\n}\n\nconst supabase = createClient(supabaseUrl, supabaseKey);\n\nasync function getHouseholds() {\n    const { data, error } = await supabase\n        .from('households')\n        .select('*');\n\n    if (error) {\n        console.error('Error fetching households:', error);\n        return null;\n    }\n\n    return data;\n}\n```\n\n## 4. Code Style Rules\n\n### MUST Follow:\n\n-   **Naming Conventions**:\n    -   Variables: `camelCase` (e.g., `userName`, `totalAmount`)\n    -   Constants: `UPPER_SNAKE_CASE` (e.g., `API_URL`, `MAX_RETRIES`)\n    -   Functions: `camelCase` (e.g., `getUserData`, `calculateTotal`)\n    -   Components: `PascalCase` (e.g., `MyComponent`, `UserProfile`)\n    -   Files: `camelCase.ts` or `PascalCase.tsx` (e.g., `userProfile.ts`, `UserProfile.tsx`)\n    -   Rationale: Consistent naming improves code readability and maintainability.\n\n-   **Code Formatting**:\n    -   Use Prettier to automatically format code.\n    -   Configuration file: `.prettierrc.js`\n    -   Rationale: Consistent formatting reduces visual clutter and improves collaboration.\n\n-   **Linting**:\n    -   Use ESLint to enforce code style rules and identify potential issues.\n    -   Configuration file: `.eslintrc.js`\n    -   Rationale: Linting helps prevent errors and maintain code quality.\n\n-   **Comments**:\n    -   Write clear and concise comments to explain complex logic.\n    -   Use JSDoc-style comments for documenting functions and components.\n    -   Rationale: Comments improve code understanding and maintainability.\n\n-   **Error Handling**:\n    -   Handle errors gracefully using `try...catch` blocks.\n    -   Log errors with informative messages.\n    -   Provide user-friendly error messages.\n    -   Rationale: Proper error handling prevents unexpected crashes and improves user experience.\n\n-   **Testing**:\n    -   Write unit tests for individual functions and components using Vitest.\n    -   Write end-to-end tests for user flows using Playwright.\n    -   Rationale: Testing ensures code correctness and prevents regressions.\n\n-   **Security**:\n    -   Sanitize user inputs to prevent XSS attacks.\n    -   Use parameterized queries to prevent SQL injection attacks.\n    -   Store sensitive data securely using bcrypt hashing and environment variables.\n    -   Rationale: Security is paramount to protect user data and prevent vulnerabilities.\n\n### MUST NOT Do:\n\n-   **Magic Numbers**:\n    -   Avoid using hardcoded numerical values without explanation.\n    -   Define constants for frequently used numbers.\n    -   ```typescript\n        // MUST NOT: Magic number\n        const calculateArea = (radius: number) => 3.14 * radius * radius;\n\n        // MUST: Using a constant\n        const PI = 3.14;\n        const calculateArea = (radius: number) => PI * radius * radius;\n        ```\n    -   Rationale: Improves code readability and makes it easier to update values.\n\n-   **Nested Callbacks**:\n    -   Avoid deeply nested callbacks, which can lead to \"callback hell.\"\n    -   Use async/await or Promises to simplify asynchronous code.\n    -   ```javascript\n        // MUST NOT: Nested callbacks\n        getData(function(a){\n            getMoreData(a, function(b){\n                getFinalData(b, function(c){\n                    console.log(c);\n                })\n            })\n        });\n\n        // MUST: Using async/await\n        async function processData() {\n            const a = await getData();\n            const b = await getMoreData(a);\n            const c = await getFinalData(b);\n            console.log(c);\n        }\n        processData();\n        ```\n    -   Rationale: Improves code readability and maintainability.\n\n-   **Global Variables**:\n    -   Avoid using global variables, which can lead to naming conflicts and unexpected behavior.\n    -   Use module-level variables or dependency injection instead.\n    -   Rationale: Reduces the risk of unintended side effects and improves code modularity.\n\n-   **Ignoring Errors**:\n    -   Never ignore errors without handling them.\n    -   Always log errors and provide appropriate feedback to the user.\n    -   ```typescript\n        // MUST NOT: Ignoring errors\n        try {\n            // Some code that might throw an error\n        } catch (e) {\n            // Empty catch block - BAD!\n        }\n\n        // MUST: Handling errors\n        try {\n            // Some code that might throw an error\n        } catch (e: any) {\n            console.error(\"An error occurred:\", e);\n            // Display a user-friendly error message\n        }\n        ```\n    -   Rationale: Prevents unexpected crashes and helps diagnose issues.\n\n-   **Over-commenting**:\n    -   Don't comment obvious things. Comments should explain *why*, not *what*.\n    -   Rationale: Too many comments can make the code harder to read.\n\n-   **Complex State Management**:\n    -   Avoid using Redux or similar libraries for simple state management.\n    -   Use `useState` or `useContext` for local or component-level state.\n    -   Rationale: Reduces complexity and improves performance.\n\n-   **Direct DOM Manipulation**:\n    -   Avoid direct DOM manipulation in React components.\n    -   Use React's state and props to update the UI.\n    -   Rationale: Ensures that React remains in control of the DOM and prevents inconsistencies.\n\n-   **Inline Styles**:\n    -   Avoid using inline styles in React components.\n    -   Use CSS classes defined in TailwindCSS or separate CSS files.\n    -   Rationale: Improves code readability and maintainability.\n\n-   **Mutating Props Directly**:\n    -   Never modify props directly within a component.\n    -   Props should be treated as read-only.\n    -   Rationale: Prevents unexpected side effects and ensures data consistency.\n\n## 5. Architecture Patterns\n\n### Component/Module Structure Guidelines\n\n-   **Separation of Concerns**: Each component or module should have a single responsibility.\n-   **Reusability**: Components should be designed to be reusable across the application.\n-   **Composition**: Complex UIs should be built by composing smaller, simpler components.\n-   **Directory Structure**: Follow the file and folder structure outlined in the TRD.\n-   **Container/Presentational Pattern (Optional)**: Consider separating container components (which handle data fetching and state management) from presentational components (which focus on rendering UI).\n\n### Data Flow Patterns\n\n-   **Unidirectional Data Flow**: Data should flow in one direction, from parent components to child components via props.\n-   **Event Handling**: Child components can communicate with parent components by triggering events via callbacks passed as props.\n-   **API Interactions**: Use services to encapsulate API calls and data transformations.\n-   **Supabase Integration**: Use the Supabase client library for database interactions.\n\n### State Management Conventions\n\n-   **Local State**: Use `useState` for managing component-specific state.\n-   **Context API**: Use Context API for sharing state between components that are not directly related.\n-   **Supabase Realtime (If Needed)**: Utilize Supabase's realtime capabilities for scenarios requiring immediate data synchronization across clients.\n-   **Avoid Overly Complex State**: Do not introduce complex state management solutions (like Redux) unless the application's complexity truly warrants it.\n\n### API Design Standards\n\n-   **RESTful Principles**: Follow RESTful principles for API design.\n-   **Consistent Endpoints**: Use consistent naming conventions for API endpoints.\n-   **JSON Format**: Use JSON for request and response bodies.\n-   **Status Codes**: Use appropriate HTTP status codes to indicate the success or failure of API requests.\n-   **Error Handling**: Return informative error messages in the response body.\n-   **Authentication**: Secure API endpoints using Supabase's authentication mechanisms.\n\n```typescript\n// MUST: Example of a RESTful API endpoint (using Next.js API routes)\n// pages/api/households.ts\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { supabase } from '@/utils/supabaseClient';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n    if (req.method === 'GET') {\n        try {\n            const { data, error } = await supabase.from('households').select('*');\n            if (error) {\n                throw error;\n            }\n            res.status(200).json(data);\n        } catch (error: any) {\n            console.error(error);\n            res.status(500).json({ error: error.message });\n        }\n    } else {\n        res.status(405).json({ error: 'Method Not Allowed' });\n    }\n}\n```\n",
      "writedAt": "2025-08-27T01:57:42.221Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-08-27T01:57:42.221Z"
    },
    {
      "type": "tdd",
      "content": "\n# TDD Process Guidelines - Cursor Rules\n\n## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification\n\n**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**\n\n## Core Cycle: Red → Green → Refactor\n\n### 1. RED Phase\n- Write a failing test FIRST\n- Test the simplest scenario\n- Verify test fails for the right reason\n- One test at a time\n\n### 2. GREEN Phase  \n- Write MINIMAL code to pass\n- \"Fake it till you make it\" is OK\n\n- YAGNI principle\n\n### 3. REFACTOR Phase\n- Remove duplication\n- Improve naming\n- Simplify structure\n- Keep tests passing\n\n## Test Quality: FIRST Principles\n- **Fast**: Milliseconds, not seconds\n- **Independent**: No shared state\n- **Repeatable**: Same result every time\n- **Self-validating**: Pass/fail, no manual checks\n- **Timely**: Written just before code\n\n## Test Structure: AAA Pattern\n```\n// Arrange\nSet up test data and dependencies\n\n// Act\nExecute the function/method\n\n// Assert\nVerify expected outcome\n```\n\n## Implementation Flow\n1. **List scenarios** before coding\n2. **Pick one scenario** → Write test\n3. **Run test** → See it fail (Red)\n4. **Implement** → Make it pass (Green)\n5. **Refactor** → Clean up (Still Green)\n6. **Commit** → Small, frequent commits\n7. **Repeat** → Next scenario\n\n## Test Pyramid Strategy\n- **Unit Tests** (70%): Fast, isolated, numerous\n- **Integration Tests** (20%): Module boundaries\n- **Acceptance Tests** (10%): User scenarios\n\n## Outside-In vs Inside-Out\n- **Outside-In**: Start with user-facing test → Mock internals → Implement details\n- **Inside-Out**: Start with core logic → Build outward → Integrate components\n\n## Common Anti-patterns to Avoid\n- Testing implementation details\n- Fragile tests tied to internals  \n- Missing assertions\n- Slow, environment-dependent tests\n- Ignored failing tests\n\n## When Tests Fail\n1. **Identify**: Regression, flaky test, or spec change?\n2. **Isolate**: Narrow down the cause\n3. **Fix**: Code bug or test bug\n4. **Learn**: Add missing test cases\n\n## Team Practices\n- CI/CD integration mandatory\n- No merge without tests\n- Test code = Production code quality\n- Pair programming for complex tests\n- Regular test refactoring\n\n## Pragmatic Exceptions\n- UI/Graphics: Manual + snapshot tests\n- Performance: Benchmark suites\n- Exploratory: Spike then test\n- Legacy: Test on change\n\n## Remember\n- Tests are living documentation\n- Test behavior, not implementation\n- Small steps, fast feedback\n- When in doubt, write a test\n",
      "writedAt": "2025-08-27T01:57:42.221Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-08-27T01:57:42.221Z"
    },
    {
      "type": "git-commit-message",
      "content": "\n# Git Commit Message Rules\n\n## Format Structure\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n## Types (Required)\n- `feat`\n- `fix`\n- `docs`\n- `style`\n- `refactor`\n- `perf`\n- `test`\n- `chore`\n- `ci`\n- `build`\n- `revert`\n\n## Scope (Optional)\n- Component, file, or feature area affected\n- Use kebab-case: `user-auth`, `payment-api`\n- Omit if change affects multiple areas\n\n## Description Rules\n- Use imperative mood\n- No capitalization of first letter\n- No period at end\n- Max 50 characters\n- Be specific and actionable\n\n## Body Guidelines\n- Wrap at 72 characters\n- Explain what and why, not how\n- Separate from description with blank line\n- Use bullet points for multiple changes\n\n## Footer Format\n- `BREAKING CHANGE:` for breaking changes\n- `Closes #123` for issue references\n- `Co-authored-by: Vooster AI (@vooster-ai)`\n\n## Examples\n```\nfeat(auth): add OAuth2 Google login\n\nfix: resolve memory leak in user session cleanup\n\ndocs(api): update authentication endpoints\n\nrefactor(utils): extract validation helpers to separate module\n\nBREAKING CHANGE: remove deprecated getUserData() method\n```\n\n## Workflow Integration\n**ALWAYS write a commit message after completing any development task, feature, or bug fix.**\n\n## Validation Checklist\n- [ ] Type is from approved list\n- [ ] Description under 50 chars\n- [ ] Imperative mood used\n- [ ] No trailing period\n- [ ] Meaningful and clear context\n    ",
      "writedAt": "2025-08-27T01:57:42.221Z"
    }
  ]
}
