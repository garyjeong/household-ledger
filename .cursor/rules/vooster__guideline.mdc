---
description:
globs:
alwaysApply: true
---
# Code Guidelines for 신혼 가계부

## 1. Project Overview

This project is a simple, manual-input-focused household accounting web application for newlyweds. It's built using Next.js, React, TypeScript, TailwindCSS, Supabase, and PostgreSQL, deployed on Vercel. Key architectural decisions include:

-   **Frontend**: Next.js for SSR/SSG, React for UI components, TailwindCSS for styling.
-   **Backend**: Supabase for authentication and database (PostgreSQL).
-   **External API**: exchangerate.host for currency exchange rates.
-   **Domain-Driven Design**: Application structure based on domains like authentication, household management, statistics, and budget management.

## 2. Core Principles

-   **Maintainability**: Write code that is easy to understand, modify, and extend.
-   **Readability**: Code should be clear, concise, and well-documented.
-   **Testability**: Design code that is easy to test using unit and E2E tests.
-   **Performance**: Optimize for speed and efficiency, ensuring a smooth user experience.
-   **Security**: Protect user data and prevent vulnerabilities through secure coding practices.

## 3. Language-Specific Guidelines

### TypeScript

#### File Organization and Directory Structure

Follow the defined structure in the TRD:

```
/
├── components/
├── pages/
├── services/
├── utils/
├── types/
├── public/
├── styles/
├── .eslintrc.js
├── .prettierrc.js
├── tsconfig.json
└── package.json
```

#### Import/Dependency Management

-   **MUST**: Use absolute imports for modules within the project.
-   **MUST**: Group imports by origin (e.g., node modules, third-party libraries, project modules).
-   **MUST**: Keep dependency lists in `package.json` up-to-date.

```typescript
// MUST: Example of correct import style
import React from 'react';
import { useState } from 'react';
import { createHousehold } from '@/services/household';
import { formatDate } from '@/utils/date';
import { Household } from '@/types/household';
```

#### Error Handling Patterns

-   **MUST**: Use `try...catch` blocks for handling potential errors in asynchronous operations (e.g., API calls).
-   **MUST**: Provide informative error messages to the user.
-   **MUST**: Log errors to the console or a logging service for debugging.
-   **MUST**: Define custom error types for specific scenarios.

```typescript
// MUST: Example of error handling in API calls
async function fetchData() {
    try {
        const response = await fetch('/api/data');
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        return data;
    } catch (error: any) {
        console.error('Failed to fetch data:', error);
        // Display user-friendly error message
        // Optionally, send error to a logging service
        throw new Error('Failed to fetch data. Please try again.');
    }
}
```

### React/Next.js

#### Component Structure

-   **MUST**: Create reusable components for UI elements.
-   **MUST**: Use functional components with hooks.
-   **MUST**: Separate UI logic from business logic.
-   **MUST**: Use descriptive names for components.

```typescript
// MUST: Example of a functional component
import React from 'react';

interface Props {
    text: string;
}

const MyComponent: React.FC<Props> = ({ text }) => {
    return <div>{text}</div>;
};

export default MyComponent;
```

#### State Management

-   **MUST**: Use React's `useState` hook for local component state.
-   **SHOULD**: Use Context API for application-wide state that doesn't require frequent updates.
-   **MUST NOT**: Use Redux or other complex state management libraries unless absolutely necessary.

#### Data Fetching

-   **MUST**: Use `getServerSideProps` or `getStaticProps` in Next.js for server-side rendering or static site generation when appropriate.
-   **MUST**: Use `useEffect` hook for client-side data fetching.
-   **MUST**: Handle loading and error states when fetching data.

```typescript
// MUST: Example of getServerSideProps
import { GetServerSideProps } from 'next';

interface Props {
    data: any;
}

const MyPage: React.FC<Props> = ({ data }) => {
    return <div>{JSON.stringify(data)}</div>;
};

export const getServerSideProps: GetServerSideProps = async (context) => {
    const res = await fetch('https://api.example.com/data');
    const data = await res.json();

    return {
        props: { data },
    };
};

export default MyPage;
```

### TailwindCSS

#### Styling Conventions

-   **MUST**: Use utility classes provided by TailwindCSS.
-   **MUST**: Avoid writing custom CSS unless absolutely necessary.
-   **MUST**: Keep class names concise and readable.
-   **MUST**: Use `@apply` directive sparingly, and only for logical groupings of styles.

```html
// MUST: Example of using TailwindCSS classes
<button className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
    Click me
</button>
```

### Supabase

#### Data Access

-   **MUST**: Use the Supabase client library for database interactions.
-   **MUST**: Handle errors appropriately when querying the database.
-   **MUST**: Use environment variables for Supabase credentials.
-   **MUST**: Implement Row Level Security (RLS) policies to protect data.

```typescript
// MUST: Example of fetching data from Supabase
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseKey) {
    throw new Error('Supabase URL and Key must be set as environment variables.');
}

const supabase = createClient(supabaseUrl, supabaseKey);

async function getHouseholds() {
    const { data, error } = await supabase
        .from('households')
        .select('*');

    if (error) {
        console.error('Error fetching households:', error);
        return null;
    }

    return data;
}
```

## 4. Code Style Rules

### MUST Follow:

-   **Naming Conventions**:
    -   Variables: `camelCase` (e.g., `userName`, `totalAmount`)
    -   Constants: `UPPER_SNAKE_CASE` (e.g., `API_URL`, `MAX_RETRIES`)
    -   Functions: `camelCase` (e.g., `getUserData`, `calculateTotal`)
    -   Components: `PascalCase` (e.g., `MyComponent`, `UserProfile`)
    -   Files: `camelCase.ts` or `PascalCase.tsx` (e.g., `userProfile.ts`, `UserProfile.tsx`)
    -   Rationale: Consistent naming improves code readability and maintainability.

-   **Code Formatting**:
    -   Use Prettier to automatically format code.
    -   Configuration file: `.prettierrc.js`
    -   Rationale: Consistent formatting reduces visual clutter and improves collaboration.

-   **Linting**:
    -   Use ESLint to enforce code style rules and identify potential issues.
    -   Configuration file: `.eslintrc.js`
    -   Rationale: Linting helps prevent errors and maintain code quality.

-   **Comments**:
    -   Write clear and concise comments to explain complex logic.
    -   Use JSDoc-style comments for documenting functions and components.
    -   Rationale: Comments improve code understanding and maintainability.

-   **Error Handling**:
    -   Handle errors gracefully using `try...catch` blocks.
    -   Log errors with informative messages.
    -   Provide user-friendly error messages.
    -   Rationale: Proper error handling prevents unexpected crashes and improves user experience.

-   **Testing**:
    -   Write unit tests for individual functions and components using Vitest.
    -   Write end-to-end tests for user flows using Playwright.
    -   Rationale: Testing ensures code correctness and prevents regressions.

-   **Security**:
    -   Sanitize user inputs to prevent XSS attacks.
    -   Use parameterized queries to prevent SQL injection attacks.
    -   Store sensitive data securely using bcrypt hashing and environment variables.
    -   Rationale: Security is paramount to protect user data and prevent vulnerabilities.

### MUST NOT Do:

-   **Magic Numbers**:
    -   Avoid using hardcoded numerical values without explanation.
    -   Define constants for frequently used numbers.
    -   ```typescript
        // MUST NOT: Magic number
        const calculateArea = (radius: number) => 3.14 * radius * radius;

        // MUST: Using a constant
        const PI = 3.14;
        const calculateArea = (radius: number) => PI * radius * radius;
        ```
    -   Rationale: Improves code readability and makes it easier to update values.

-   **Nested Callbacks**:
    -   Avoid deeply nested callbacks, which can lead to "callback hell."
    -   Use async/await or Promises to simplify asynchronous code.
    -   ```javascript
        // MUST NOT: Nested callbacks
        getData(function(a){
            getMoreData(a, function(b){
                getFinalData(b, function(c){
                    console.log(c);
                })
            })
        });

        // MUST: Using async/await
        async function processData() {
            const a = await getData();
            const b = await getMoreData(a);
            const c = await getFinalData(b);
            console.log(c);
        }
        processData();
        ```
    -   Rationale: Improves code readability and maintainability.

-   **Global Variables**:
    -   Avoid using global variables, which can lead to naming conflicts and unexpected behavior.
    -   Use module-level variables or dependency injection instead.
    -   Rationale: Reduces the risk of unintended side effects and improves code modularity.

-   **Ignoring Errors**:
    -   Never ignore errors without handling them.
    -   Always log errors and provide appropriate feedback to the user.
    -   ```typescript
        // MUST NOT: Ignoring errors
        try {
            // Some code that might throw an error
        } catch (e) {
            // Empty catch block - BAD!
        }

        // MUST: Handling errors
        try {
            // Some code that might throw an error
        } catch (e: any) {
            console.error("An error occurred:", e);
            // Display a user-friendly error message
        }
        ```
    -   Rationale: Prevents unexpected crashes and helps diagnose issues.

-   **Over-commenting**:
    -   Don't comment obvious things. Comments should explain *why*, not *what*.
    -   Rationale: Too many comments can make the code harder to read.

-   **Complex State Management**:
    -   Avoid using Redux or similar libraries for simple state management.
    -   Use `useState` or `useContext` for local or component-level state.
    -   Rationale: Reduces complexity and improves performance.

-   **Direct DOM Manipulation**:
    -   Avoid direct DOM manipulation in React components.
    -   Use React's state and props to update the UI.
    -   Rationale: Ensures that React remains in control of the DOM and prevents inconsistencies.

-   **Inline Styles**:
    -   Avoid using inline styles in React components.
    -   Use CSS classes defined in TailwindCSS or separate CSS files.
    -   Rationale: Improves code readability and maintainability.

-   **Mutating Props Directly**:
    -   Never modify props directly within a component.
    -   Props should be treated as read-only.
    -   Rationale: Prevents unexpected side effects and ensures data consistency.

## 5. Architecture Patterns

### Component/Module Structure Guidelines

-   **Separation of Concerns**: Each component or module should have a single responsibility.
-   **Reusability**: Components should be designed to be reusable across the application.
-   **Composition**: Complex UIs should be built by composing smaller, simpler components.
-   **Directory Structure**: Follow the file and folder structure outlined in the TRD.
-   **Container/Presentational Pattern (Optional)**: Consider separating container components (which handle data fetching and state management) from presentational components (which focus on rendering UI).

### Data Flow Patterns

-   **Unidirectional Data Flow**: Data should flow in one direction, from parent components to child components via props.
-   **Event Handling**: Child components can communicate with parent components by triggering events via callbacks passed as props.
-   **API Interactions**: Use services to encapsulate API calls and data transformations.
-   **Supabase Integration**: Use the Supabase client library for database interactions.

### State Management Conventions

-   **Local State**: Use `useState` for managing component-specific state.
-   **Context API**: Use Context API for sharing state between components that are not directly related.
-   **Supabase Realtime (If Needed)**: Utilize Supabase's realtime capabilities for scenarios requiring immediate data synchronization across clients.
-   **Avoid Overly Complex State**: Do not introduce complex state management solutions (like Redux) unless the application's complexity truly warrants it.

### API Design Standards

-   **RESTful Principles**: Follow RESTful principles for API design.
-   **Consistent Endpoints**: Use consistent naming conventions for API endpoints.
-   **JSON Format**: Use JSON for request and response bodies.
-   **Status Codes**: Use appropriate HTTP status codes to indicate the success or failure of API requests.
-   **Error Handling**: Return informative error messages in the response body.
-   **Authentication**: Secure API endpoints using Supabase's authentication mechanisms.

```typescript
// MUST: Example of a RESTful API endpoint (using Next.js API routes)
// pages/api/households.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { supabase } from '@/utils/supabaseClient';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    if (req.method === 'GET') {
        try {
            const { data, error } = await supabase.from('households').select('*');
            if (error) {
                throw error;
            }
            res.status(200).json(data);
        } catch (error: any) {
            console.error(error);
            res.status(500).json({ error: error.message });
        }
    } else {
        res.status(405).json({ error: 'Method Not Allowed' });
    }
}
```

